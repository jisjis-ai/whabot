const config = require('../config/settings');
const Helpers = require('../utils/helpers');
const GroupHandler = require('./groupHandler');
const fs = require('fs');
const path = require('path');

class AdminHandler {
    constructor(client) {
        this.client = client;
        this.adminSessions = new Map(); // Sess√µes de admin logados
        this.groupHandler = new GroupHandler(client);
    }

    async handleAdminMessage(msg) {
        const userNumber = msg.from;
        const messageBody = msg.body.trim();
        const chat = await msg.getChat();

        // Verificar se √© comando de login
        if (messageBody === '/admin') {
            await this.handleAdminLogin(msg, chat);
            return;
        }

        // Verificar se est√° logado
        if (!this.adminSessions.has(userNumber)) {
            return; // N√£o √© admin logado, ignorar
        }

        // Processar comandos de admin
        await this.processAdminCommand(msg, chat, messageBody);
    }

    async handleAdminLogin(msg, chat) {
        await Helpers.simulateTyping(chat, 1000);
        await msg.reply(`üîê *√ÅREA ADMINISTRATIVA*

Por favor, digite suas credenciais no formato:
\`\`\`
Email: seu@email.com
Senha: suasenha
\`\`\`

‚ö†Ô∏è *Aten√ß√£o:* Use exatamente este formato!`);

        // Marcar como aguardando login
        this.adminSessions.set(msg.from, { status: 'awaiting_credentials' });
        
        Helpers.log(`Tentativa de login admin de ${msg.from}`, 'ADMIN');
    }

    async processAdminCommand(msg, chat, messageBody) {
        const session = this.adminSessions.get(msg.from);
        
        if (session.status === 'awaiting_credentials') {
            await this.validateCredentials(msg, chat, messageBody);
            return;
        }

        if (session.status !== 'authenticated') {
            return;
        }

        // Comandos dispon√≠veis para admin autenticado
        const command = messageBody.toLowerCase().split(' ')[0];

        switch (command) {
            case '/help':
                await this.showAdminHelp(msg, chat);
                break;
            
            case '/contacts':
                await this.sendContacts(msg, chat);
                break;
            
            case '/broadcast':
                await this.handleBroadcast(msg, chat, messageBody);
                break;
            
            case '/config':
                await this.showConfig(msg, chat);
                break;
            
            case '/setmessage':
                await this.setMessage(msg, chat, messageBody);
                break;
            
            case '/setlink':
                await this.setLink(msg, chat, messageBody);
                break;
            
            case '/stats':
                await this.showStats(msg, chat);
                break;
            
            case '/sendaudio':
                await this.handleAudioBroadcast(msg, chat);
                break;
            
            case '/sendmedia':
                await this.handleMediaBroadcast(msg, chat);
                break;

            // Novos comandos de grupos
            case '/autoresponder':
                await this.toggleAutoResponder(msg, chat, messageBody);
                break;

            case '/capturarcontatos':
                await this.captureGroupContacts(msg, chat);
                break;

            case '/mensagemgrupos':
                await this.broadcastToGroups(msg, chat, messageBody);
                break;

            case '/entrargrupos':
                await this.joinRandomGroups(msg, chat, messageBody);
                break;

            case '/statsgrupos':
                await this.showGroupStats(msg, chat);
                break;
            
            default:
                await msg.reply('‚ùå Comando n√£o reconhecido. Digite /help para ver os comandos dispon√≠veis.');
        }
    }

    async validateCredentials(msg, chat, messageBody) {
        const lines = messageBody.split('\n');
        let email = '';
        let password = '';

        for (const line of lines) {
            if (line.toLowerCase().includes('email:')) {
                email = line.split(':')[1]?.trim();
            }
            if (line.toLowerCase().includes('senha:')) {
                password = line.split(':')[1]?.trim();
            }
        }

        if (email === config.admin.email && password === config.admin.password) {
            // Login bem-sucedido
            this.adminSessions.set(msg.from, { 
                status: 'authenticated', 
                loginTime: new Date() 
            });
            
            // Adicionar n√∫mero aos admins autorizados
            if (!config.admin.numbers.includes(msg.from)) {
                config.admin.numbers.push(msg.from);
            }

            await Helpers.simulateTyping(chat, 1000);
            await msg.reply(`‚úÖ *LOGIN REALIZADO COM SUCESSO!*

üéõÔ∏è *PAINEL ADMINISTRATIVO ATIVADO*

Digite /help para ver todos os comandos dispon√≠veis.

üîß Voc√™ agora tem acesso total ao sistema!`);

            Helpers.log(`Admin logado com sucesso: ${msg.from}`, 'ADMIN');
        } else {
            await msg.reply(`‚ùå *CREDENCIAIS INV√ÅLIDAS!*

Tente novamente com o formato correto:
\`\`\`
Email: seu@email.com
Senha: suasenha
\`\`\``);
            
            // Remover sess√£o
            this.adminSessions.delete(msg.from);
            
            Helpers.log(`Tentativa de login falhada: ${msg.from}`, 'ADMIN');
        }
    }

    async showAdminHelp(msg, chat) {
        const helpText = `üéõÔ∏è *COMANDOS ADMINISTRATIVOS*

üìä *INFORMA√á√ïES:*
‚Ä¢ \`/stats\` - Estat√≠sticas do bot
‚Ä¢ \`/contacts\` - Baixar lista de contatos
‚Ä¢ \`/config\` - Ver configura√ß√µes atuais
‚Ä¢ \`/statsgrupos\` - Estat√≠sticas de grupos

üìù *CONFIGURA√á√ïES:*
‚Ä¢ \`/setmessage [tipo] [mensagem]\` - Alterar mensagens
‚Ä¢ \`/setlink [casa] [link]\` - Alterar links das casas

üì¢ *ENVIOS EM MASSA:*
‚Ä¢ \`/broadcast [mensagem]\` - Enviar mensagem para todos
‚Ä¢ \`/sendaudio\` - Enviar √°udio (responda um √°udio)
‚Ä¢ \`/sendmedia\` - Enviar m√≠dia (responda uma m√≠dia)

üë• *COMANDOS DE GRUPOS:*
‚Ä¢ \`/autoresponder on/off\` - Ativar/desativar auto-resposta
‚Ä¢ \`/capturarcontatos\` - Capturar contatos de todos os grupos
‚Ä¢ \`/mensagemgrupos [mensagem]\` - Enviar para todos os grupos
‚Ä¢ \`/entrargrupos [n√∫mero]\` - Entrar em grupos aleat√≥rios

üí° *EXEMPLOS:*
\`/autoresponder on\` - Ativa auto-resposta em grupos
\`/entrargrupos 50\` - Tenta entrar em 50 grupos
\`/mensagemgrupos Promo√ß√£o especial!\` - Envia para todos os grupos

‚ö†Ô∏è *Cuidado com envios em massa para evitar banimento!*`;

        await msg.reply(helpText);
    }

    async sendContacts(msg, chat) {
        const contacts = Helpers.getContacts();
        
        // Criar arquivo tempor√°rio
        const tempFile = path.join(__dirname, '../temp/contacts.txt');
        const dir = path.dirname(tempFile);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
        
        fs.writeFileSync(tempFile, contacts);
        
        // Enviar arquivo
        const media = require('whatsapp-web.js').MessageMedia.fromFilePath(tempFile);
        await chat.sendMessage(media, { caption: 'üìã Lista de contatos capturados pelo bot' });
        
        // Limpar arquivo tempor√°rio
        fs.unlinkSync(tempFile);
        
        Helpers.log(`Contatos enviados para admin ${msg.from}`, 'ADMIN');
    }

    async handleBroadcast(msg, chat, messageBody) {
        const broadcastMessage = messageBody.replace('/broadcast', '').trim();
        
        if (!broadcastMessage) {
            await msg.reply('‚ùå Digite a mensagem ap√≥s o comando /broadcast');
            return;
        }

        const contacts = Array.from(config.userStates.keys());
        let successCount = 0;
        let errorCount = 0;

        await msg.reply(`üì¢ Iniciando envio em massa para ${contacts.length} contatos...`);

        for (let i = 0; i < contacts.length; i++) {
            try {
                const contact = contacts[i];
                const variation = Helpers.generateMessageVariation(broadcastMessage);
                
                await this.client.sendMessage(contact, variation);
                successCount++;
                
                // Delay aleat√≥rio entre envios (3-8 segundos)
                const randomDelay = Math.floor(Math.random() * 5000) + 3000;
                await Helpers.delay(randomDelay);
                
                // Atualizar progresso a cada 10 envios
                if ((i + 1) % 10 === 0) {
                    await msg.reply(`üìä Progresso: ${i + 1}/${contacts.length} enviados`);
                }
                
            } catch (error) {
                errorCount++;
                Helpers.log(`Erro ao enviar para ${contacts[i]}: ${error.message}`, 'ERROR');
            }
        }

        const report = `üìä *RELAT√ìRIO DE ENVIO EM MASSA*

‚úÖ Enviados com sucesso: ${successCount}
‚ùå Erros: ${errorCount}
üì± Total de contatos: ${contacts.length}

‚è∞ Conclu√≠do em: ${new Date().toLocaleString('pt-BR')}`;

        await msg.reply(report);
        Helpers.log(`Broadcast conclu√≠do: ${successCount} sucessos, ${errorCount} erros`, 'ADMIN');
    }

    async showStats(msg, chat) {
        const totalUsers = config.userStates.size;
        const usersByState = {};
        
        for (const [user, state] of config.userStates.entries()) {
            usersByState[state] = (usersByState[state] || 0) + 1;
        }

        const statsText = `üìä *ESTAT√çSTICAS DO BOT*

üë• *Total de usu√°rios:* ${totalUsers}

üìà *Por estado:*
‚Ä¢ Inicial: ${usersByState.initial || 0}
‚Ä¢ Aguardando dep√≥sito: ${usersByState.waiting_deposit || 0}
‚Ä¢ Aguardando screenshot: ${usersByState.waiting_screenshot || 0}
‚Ä¢ Conclu√≠do: ${usersByState.completed || 0}

üïê *√öltima atualiza√ß√£o:* ${new Date().toLocaleString('pt-BR')}`;

        await msg.reply(statsText);
    }

    async setMessage(msg, chat, messageBody) {
        const parts = messageBody.split(' ');
        if (parts.length < 3) {
            await msg.reply('‚ùå Formato: /setmessage [tipo] [nova mensagem]\n\nTipos: welcome, depositRequest, needPhoto, groupAccess, additionalHouses');
            return;
        }

        const messageType = parts[1];
        const newMessage = parts.slice(2).join(' ');

        if (config.messages[messageType]) {
            config.messages[messageType] = newMessage;
            await msg.reply(`‚úÖ Mensagem "${messageType}" atualizada com sucesso!`);
            Helpers.log(`Mensagem ${messageType} alterada por admin ${msg.from}`, 'ADMIN');
        } else {
            await msg.reply('‚ùå Tipo de mensagem inv√°lido!');
        }
    }

    async setLink(msg, chat, messageBody) {
        const parts = messageBody.split(' ');
        if (parts.length < 3) {
            await msg.reply('‚ùå Formato: /setlink [casa] [novo link]\n\nCasas: casa1, casa2, casa3, casa4, group');
            return;
        }

        const linkType = parts[1];
        const newLink = parts[2];

        if (linkType === 'group') {
            config.groupLink = newLink;
            await msg.reply('‚úÖ Link do grupo atualizado!');
        } else if (config.houses[linkType]) {
            config.houses[linkType] = newLink;
            await msg.reply(`‚úÖ Link da ${linkType} atualizado!`);
        } else {
            await msg.reply('‚ùå Tipo de link inv√°lido!');
        }

        Helpers.log(`Link ${linkType} alterado por admin ${msg.from}`, 'ADMIN');
    }

    async showConfig(msg, chat) {
        const configText = `‚öôÔ∏è *CONFIGURA√á√ïES ATUAIS*

üè† *Links das Casas:*
‚Ä¢ Casa 1: ${config.houses.casa1}
‚Ä¢ Casa 2: ${config.houses.casa2}
‚Ä¢ Casa 3: ${config.houses.casa3}
‚Ä¢ Casa 4: ${config.houses.casa4}

üë• *Grupo VIP:*
${config.groupLink}

ü§ñ *Auto-resposta grupos:* ${config.groupSettings.autoResponder ? '‚úÖ ATIVA' : '‚ùå INATIVA'}

üéõÔ∏è *Admins ativos:* ${config.admin.numbers.length}`;

        await msg.reply(configText);
    }

    async handleAudioBroadcast(msg, chat) {
        if (!msg.hasQuotedMsg) {
            await msg.reply('‚ùå Responda um √°udio com /sendaudio para enviar em massa');
            return;
        }

        const quotedMsg = await msg.getQuotedMessage();
        if (quotedMsg.type !== 'ptt' && quotedMsg.type !== 'audio') {
            await msg.reply('‚ùå A mensagem respondida deve ser um √°udio');
            return;
        }

        const media = await quotedMsg.downloadMedia();
        const contacts = Array.from(config.userStates.keys());
        
        await msg.reply(`üéµ Iniciando envio de √°udio para ${contacts.length} contatos...`);

        let successCount = 0;
        for (const contact of contacts) {
            try {
                await this.client.sendMessage(contact, media);
                successCount++;
                await Helpers.delay(Math.floor(Math.random() * 5000) + 3000);
            } catch (error) {
                Helpers.log(`Erro ao enviar √°udio para ${contact}: ${error.message}`, 'ERROR');
            }
        }

        await msg.reply(`‚úÖ √Åudio enviado para ${successCount} contatos!`);
    }

    async handleMediaBroadcast(msg, chat) {
        if (!msg.hasQuotedMsg) {
            await msg.reply('‚ùå Responda uma m√≠dia (foto/v√≠deo/documento) com /sendmedia para enviar em massa');
            return;
        }

        const quotedMsg = await msg.getQuotedMessage();
        if (!quotedMsg.hasMedia) {
            await msg.reply('‚ùå A mensagem respondida deve conter m√≠dia');
            return;
        }

        const media = await quotedMsg.downloadMedia();
        const contacts = Array.from(config.userStates.keys());
        
        await msg.reply(`üìé Iniciando envio de m√≠dia para ${contacts.length} contatos...`);

        let successCount = 0;
        for (const contact of contacts) {
            try {
                await this.client.sendMessage(contact, media);
                successCount++;
                await Helpers.delay(Math.floor(Math.random() * 5000) + 3000);
            } catch (error) {
                Helpers.log(`Erro ao enviar m√≠dia para ${contact}: ${error.message}`, 'ERROR');
            }
        }

        await msg.reply(`‚úÖ M√≠dia enviada para ${successCount} contatos!`);
    }

    // Novos m√©todos para grupos

    async toggleAutoResponder(msg, chat, messageBody) {
        const parts = messageBody.split(' ');
        if (parts.length < 2) {
            await msg.reply('‚ùå Formato: /autoresponder on/off');
            return;
        }

        const action = parts[1].toLowerCase();
        
        if (action === 'on') {
            config.groupSettings.autoResponder = true;
            await msg.reply(`‚úÖ *AUTO-RESPOSTA EM GRUPOS ATIVADA!*

ü§ñ O bot agora responder√° automaticamente em grupos com:
‚Ä¢ Delay de 30s a 2min entre respostas
‚Ä¢ Cooldown de 5min por grupo
‚Ä¢ Mensagens variadas com links de cadastro

‚ö†Ô∏è *CUIDADO:* Use com modera√ß√£o para evitar banimento!`);
        } else if (action === 'off') {
            config.groupSettings.autoResponder = false;
            await msg.reply('‚ùå Auto-resposta em grupos DESATIVADA!');
        } else {
            await msg.reply('‚ùå Use: /autoresponder on ou /autoresponder off');
            return;
        }

        Helpers.log(`Auto-resposta grupos ${action} por admin ${msg.from}`, 'ADMIN');
    }

    async captureGroupContacts(msg, chat) {
        await msg.reply('üîÑ Iniciando captura de contatos de todos os grupos...\n‚è∞ Isso pode levar alguns minutos...');

        const result = await this.groupHandler.captureAllGroupContacts();

        if (result.success) {
            await msg.reply(result.message);

            // Enviar arquivo com contatos
            const tempFile = path.join(__dirname, '../temp/', result.filename);
            const dir = path.dirname(tempFile);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }

            fs.writeFileSync(tempFile, result.contacts);

            const media = require('whatsapp-web.js').MessageMedia.fromFilePath(tempFile);
            await chat.sendMessage(media, { 
                caption: `üìã *CONTATOS CAPTURADOS DOS GRUPOS*\n\n${result.message}` 
            });

            // Limpar arquivo tempor√°rio
            fs.unlinkSync(tempFile);
        } else {
            await msg.reply(result.message);
        }
    }

    async broadcastToGroups(msg, chat, messageBody) {
        const message = messageBody.replace('/mensagemgrupos', '').trim();
        
        if (!message) {
            await msg.reply('‚ùå Digite a mensagem ap√≥s o comando /mensagemgrupos');
            return;
        }

        await msg.reply('üì¢ Iniciando envio para todos os grupos...');

        const result = await this.groupHandler.broadcastToGroups(message);

        if (result.success) {
            const report = `üìä *RELAT√ìRIO DE ENVIO PARA GRUPOS*

‚úÖ Enviados com sucesso: ${result.sent}
‚ùå Erros: ${result.errors}
üë• Total de grupos: ${result.total}

‚è∞ Conclu√≠do em: ${new Date().toLocaleString('pt-BR')}`;

            await msg.reply(report);
        } else {
            await msg.reply(`‚ùå Erro no envio: ${result.message}`);
        }
    }

    async joinRandomGroups(msg, chat, messageBody) {
        const parts = messageBody.split(' ');
        if (parts.length < 2) {
            await msg.reply('‚ùå Formato: /entrargrupos [n√∫mero]\n\nExemplo: /entrargrupos 50');
            return;
        }

        const targetCount = parseInt(parts[1]);
        if (isNaN(targetCount) || targetCount < 1 || targetCount > 100) {
            await msg.reply('‚ùå N√∫mero deve ser entre 1 e 100');
            return;
        }

        await msg.reply(`üîÑ Iniciando processo para entrar em ${targetCount} grupos...\n‚è∞ Isso pode levar bastante tempo...`);

        const result = await this.groupHandler.joinRandomGroups(targetCount);

        if (result.success) {
            const report = `üìä *RELAT√ìRIO DE ENTRADA EM GRUPOS*

‚úÖ Grupos entrados: ${result.joined}
üéØ Meta: ${result.target}
üîÑ Tentativas: ${result.attempts}

‚è∞ Conclu√≠do em: ${new Date().toLocaleString('pt-BR')}`;

            await msg.reply(report);
        } else {
            await msg.reply(`‚ùå Erro: ${result.message}`);
        }
    }

    async showGroupStats(msg, chat) {
        const stats = await this.groupHandler.getGroupStats();

        if (stats) {
            const statsText = `üìä *ESTAT√çSTICAS DE GRUPOS*

üë• *Total de grupos:* ${stats.totalGroups}
üëë *Admin em:* ${stats.adminGroups} grupos
üë§ *Membro em:* ${stats.memberGroups} grupos
üì± *Total de participantes:* ${stats.totalParticipants}

ü§ñ *Auto-resposta:* ${stats.autoResponder ? '‚úÖ ATIVA' : '‚ùå INATIVA'}

üéØ *Entrada autom√°tica:*
‚Ä¢ Meta: ${stats.joinTarget} grupos
‚Ä¢ Conseguiu entrar: ${stats.joinedCount} grupos

üïê *√öltima atualiza√ß√£o:* ${new Date().toLocaleString('pt-BR')}`;

            await msg.reply(statsText);
        } else {
            await msg.reply('‚ùå Erro ao obter estat√≠sticas de grupos');
        }
    }
}

module.exports = AdminHandler;